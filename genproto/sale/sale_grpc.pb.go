// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v5.27.1
// source: sale.proto

package sale

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ProductClient is the client API for Product service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProductClient interface {
	CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*ProductId, error)
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*GetProductResponse, error)
	GetProductById(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*GetProductByIdResponse, error)
	UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*Void, error)
	DeleteProduct(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*Void, error)
	IsProductOk(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*Void, error)
	AddPhotosToProduct(ctx context.Context, in *AddPhotosRequest, opts ...grpc.CallOption) (*Void, error)
	DeletePhotosFromProduct(ctx context.Context, in *DeletePhotosRequest, opts ...grpc.CallOption) (*Void, error)
}

type productClient struct {
	cc grpc.ClientConnInterface
}

func NewProductClient(cc grpc.ClientConnInterface) ProductClient {
	return &productClient{cc}
}

func (c *productClient) CreateProduct(ctx context.Context, in *CreateProductRequest, opts ...grpc.CallOption) (*ProductId, error) {
	out := new(ProductId)
	err := c.cc.Invoke(ctx, "/sale.Product/CreateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*GetProductResponse, error) {
	out := new(GetProductResponse)
	err := c.cc.Invoke(ctx, "/sale.Product/GetProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) GetProductById(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*GetProductByIdResponse, error) {
	out := new(GetProductByIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Product/GetProductById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) UpdateProduct(ctx context.Context, in *UpdateProductRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Product/UpdateProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) DeleteProduct(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Product/DeleteProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) IsProductOk(ctx context.Context, in *ProductId, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Product/IsProductOk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) AddPhotosToProduct(ctx context.Context, in *AddPhotosRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Product/AddPhotosToProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *productClient) DeletePhotosFromProduct(ctx context.Context, in *DeletePhotosRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Product/DeletePhotosFromProduct", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProductServer is the server API for Product service.
// All implementations must embed UnimplementedProductServer
// for forward compatibility
type ProductServer interface {
	CreateProduct(context.Context, *CreateProductRequest) (*ProductId, error)
	GetProduct(context.Context, *GetProductRequest) (*GetProductResponse, error)
	GetProductById(context.Context, *ProductId) (*GetProductByIdResponse, error)
	UpdateProduct(context.Context, *UpdateProductRequest) (*Void, error)
	DeleteProduct(context.Context, *ProductId) (*Void, error)
	IsProductOk(context.Context, *ProductId) (*Void, error)
	AddPhotosToProduct(context.Context, *AddPhotosRequest) (*Void, error)
	DeletePhotosFromProduct(context.Context, *DeletePhotosRequest) (*Void, error)
	mustEmbedUnimplementedProductServer()
}

// UnimplementedProductServer must be embedded to have forward compatible implementations.
type UnimplementedProductServer struct {
}

func (UnimplementedProductServer) CreateProduct(context.Context, *CreateProductRequest) (*ProductId, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProduct not implemented")
}
func (UnimplementedProductServer) GetProduct(context.Context, *GetProductRequest) (*GetProductResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}
func (UnimplementedProductServer) GetProductById(context.Context, *ProductId) (*GetProductByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProductById not implemented")
}
func (UnimplementedProductServer) UpdateProduct(context.Context, *UpdateProductRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProduct not implemented")
}
func (UnimplementedProductServer) DeleteProduct(context.Context, *ProductId) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProduct not implemented")
}
func (UnimplementedProductServer) IsProductOk(context.Context, *ProductId) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProductOk not implemented")
}
func (UnimplementedProductServer) AddPhotosToProduct(context.Context, *AddPhotosRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPhotosToProduct not implemented")
}
func (UnimplementedProductServer) DeletePhotosFromProduct(context.Context, *DeletePhotosRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePhotosFromProduct not implemented")
}
func (UnimplementedProductServer) mustEmbedUnimplementedProductServer() {}

// UnsafeProductServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProductServer will
// result in compilation errors.
type UnsafeProductServer interface {
	mustEmbedUnimplementedProductServer()
}

func RegisterProductServer(s grpc.ServiceRegistrar, srv ProductServer) {
	s.RegisterService(&Product_ServiceDesc, srv)
}

func _Product_CreateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).CreateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/CreateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).CreateProduct(ctx, req.(*CreateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/GetProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_GetProductById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).GetProductById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/GetProductById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).GetProductById(ctx, req.(*ProductId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_UpdateProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).UpdateProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/UpdateProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).UpdateProduct(ctx, req.(*UpdateProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_DeleteProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).DeleteProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/DeleteProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).DeleteProduct(ctx, req.(*ProductId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_IsProductOk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProductId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).IsProductOk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/IsProductOk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).IsProductOk(ctx, req.(*ProductId))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_AddPhotosToProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).AddPhotosToProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/AddPhotosToProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).AddPhotosToProduct(ctx, req.(*AddPhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Product_DeletePhotosFromProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePhotosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProductServer).DeletePhotosFromProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Product/DeletePhotosFromProduct",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProductServer).DeletePhotosFromProduct(ctx, req.(*DeletePhotosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Product_ServiceDesc is the grpc.ServiceDesc for Product service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Product_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sale.Product",
	HandlerType: (*ProductServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProduct",
			Handler:    _Product_CreateProduct_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _Product_GetProduct_Handler,
		},
		{
			MethodName: "GetProductById",
			Handler:    _Product_GetProductById_Handler,
		},
		{
			MethodName: "UpdateProduct",
			Handler:    _Product_UpdateProduct_Handler,
		},
		{
			MethodName: "DeleteProduct",
			Handler:    _Product_DeleteProduct_Handler,
		},
		{
			MethodName: "IsProductOk",
			Handler:    _Product_IsProductOk_Handler,
		},
		{
			MethodName: "AddPhotosToProduct",
			Handler:    _Product_AddPhotosToProduct_Handler,
		},
		{
			MethodName: "DeletePhotosFromProduct",
			Handler:    _Product_DeletePhotosFromProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sale.proto",
}

// ProcessClient is the client API for Process service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessClient interface {
	CreateProcess(ctx context.Context, in *CreateProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error)
	GetProcessOfUserByProductId(ctx context.Context, in *GetProcessOfUserByProductIdRequest, opts ...grpc.CallOption) (*GetProcessOfUserByProductIdResponse, error)
	GetProcessByUserId(ctx context.Context, in *GetProcessByUserIdRequest, opts ...grpc.CallOption) (*GetProcessByUserIdResponse, error)
	GetProcessByProductId(ctx context.Context, in *GetProcessByProductIdRequest, opts ...grpc.CallOption) (*GetProcessByProductIdResponse, error)
	GetProcessById(ctx context.Context, in *GetProcessByIdRequest, opts ...grpc.CallOption) (*GetProcessByIdResponse, error)
	UpdateProcess(ctx context.Context, in *UpdateProcessRequest, opts ...grpc.CallOption) (*Void, error)
	CancelProcess(ctx context.Context, in *CancelProcessRequest, opts ...grpc.CallOption) (*CancelProcessResponse, error)
}

type processClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessClient(cc grpc.ClientConnInterface) ProcessClient {
	return &processClient{cc}
}

func (c *processClient) CreateProcess(ctx context.Context, in *CreateProcessRequest, opts ...grpc.CallOption) (*ProcessResponse, error) {
	out := new(ProcessResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/CreateProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) GetProcessOfUserByProductId(ctx context.Context, in *GetProcessOfUserByProductIdRequest, opts ...grpc.CallOption) (*GetProcessOfUserByProductIdResponse, error) {
	out := new(GetProcessOfUserByProductIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/GetProcessOfUserByProductId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) GetProcessByUserId(ctx context.Context, in *GetProcessByUserIdRequest, opts ...grpc.CallOption) (*GetProcessByUserIdResponse, error) {
	out := new(GetProcessByUserIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/GetProcessByUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) GetProcessByProductId(ctx context.Context, in *GetProcessByProductIdRequest, opts ...grpc.CallOption) (*GetProcessByProductIdResponse, error) {
	out := new(GetProcessByProductIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/GetProcessByProductId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) GetProcessById(ctx context.Context, in *GetProcessByIdRequest, opts ...grpc.CallOption) (*GetProcessByIdResponse, error) {
	out := new(GetProcessByIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/GetProcessById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) UpdateProcess(ctx context.Context, in *UpdateProcessRequest, opts ...grpc.CallOption) (*Void, error) {
	out := new(Void)
	err := c.cc.Invoke(ctx, "/sale.Process/UpdateProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processClient) CancelProcess(ctx context.Context, in *CancelProcessRequest, opts ...grpc.CallOption) (*CancelProcessResponse, error) {
	out := new(CancelProcessResponse)
	err := c.cc.Invoke(ctx, "/sale.Process/CancelProcess", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessServer is the server API for Process service.
// All implementations must embed UnimplementedProcessServer
// for forward compatibility
type ProcessServer interface {
	CreateProcess(context.Context, *CreateProcessRequest) (*ProcessResponse, error)
	GetProcessOfUserByProductId(context.Context, *GetProcessOfUserByProductIdRequest) (*GetProcessOfUserByProductIdResponse, error)
	GetProcessByUserId(context.Context, *GetProcessByUserIdRequest) (*GetProcessByUserIdResponse, error)
	GetProcessByProductId(context.Context, *GetProcessByProductIdRequest) (*GetProcessByProductIdResponse, error)
	GetProcessById(context.Context, *GetProcessByIdRequest) (*GetProcessByIdResponse, error)
	UpdateProcess(context.Context, *UpdateProcessRequest) (*Void, error)
	CancelProcess(context.Context, *CancelProcessRequest) (*CancelProcessResponse, error)
	mustEmbedUnimplementedProcessServer()
}

// UnimplementedProcessServer must be embedded to have forward compatible implementations.
type UnimplementedProcessServer struct {
}

func (UnimplementedProcessServer) CreateProcess(context.Context, *CreateProcessRequest) (*ProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProcess not implemented")
}
func (UnimplementedProcessServer) GetProcessOfUserByProductId(context.Context, *GetProcessOfUserByProductIdRequest) (*GetProcessOfUserByProductIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessOfUserByProductId not implemented")
}
func (UnimplementedProcessServer) GetProcessByUserId(context.Context, *GetProcessByUserIdRequest) (*GetProcessByUserIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessByUserId not implemented")
}
func (UnimplementedProcessServer) GetProcessByProductId(context.Context, *GetProcessByProductIdRequest) (*GetProcessByProductIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessByProductId not implemented")
}
func (UnimplementedProcessServer) GetProcessById(context.Context, *GetProcessByIdRequest) (*GetProcessByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProcessById not implemented")
}
func (UnimplementedProcessServer) UpdateProcess(context.Context, *UpdateProcessRequest) (*Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProcess not implemented")
}
func (UnimplementedProcessServer) CancelProcess(context.Context, *CancelProcessRequest) (*CancelProcessResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelProcess not implemented")
}
func (UnimplementedProcessServer) mustEmbedUnimplementedProcessServer() {}

// UnsafeProcessServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessServer will
// result in compilation errors.
type UnsafeProcessServer interface {
	mustEmbedUnimplementedProcessServer()
}

func RegisterProcessServer(s grpc.ServiceRegistrar, srv ProcessServer) {
	s.RegisterService(&Process_ServiceDesc, srv)
}

func _Process_CreateProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).CreateProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/CreateProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).CreateProcess(ctx, req.(*CreateProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_GetProcessOfUserByProductId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessOfUserByProductIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).GetProcessOfUserByProductId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/GetProcessOfUserByProductId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).GetProcessOfUserByProductId(ctx, req.(*GetProcessOfUserByProductIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_GetProcessByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).GetProcessByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/GetProcessByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).GetProcessByUserId(ctx, req.(*GetProcessByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_GetProcessByProductId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessByProductIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).GetProcessByProductId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/GetProcessByProductId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).GetProcessByProductId(ctx, req.(*GetProcessByProductIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_GetProcessById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProcessByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).GetProcessById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/GetProcessById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).GetProcessById(ctx, req.(*GetProcessByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_UpdateProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).UpdateProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/UpdateProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).UpdateProcess(ctx, req.(*UpdateProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Process_CancelProcess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelProcessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessServer).CancelProcess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Process/CancelProcess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessServer).CancelProcess(ctx, req.(*CancelProcessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Process_ServiceDesc is the grpc.ServiceDesc for Process service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Process_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sale.Process",
	HandlerType: (*ProcessServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateProcess",
			Handler:    _Process_CreateProcess_Handler,
		},
		{
			MethodName: "GetProcessOfUserByProductId",
			Handler:    _Process_GetProcessOfUserByProductId_Handler,
		},
		{
			MethodName: "GetProcessByUserId",
			Handler:    _Process_GetProcessByUserId_Handler,
		},
		{
			MethodName: "GetProcessByProductId",
			Handler:    _Process_GetProcessByProductId_Handler,
		},
		{
			MethodName: "GetProcessById",
			Handler:    _Process_GetProcessById_Handler,
		},
		{
			MethodName: "UpdateProcess",
			Handler:    _Process_UpdateProcess_Handler,
		},
		{
			MethodName: "CancelProcess",
			Handler:    _Process_CancelProcess_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sale.proto",
}

// WishlistClient is the client API for Wishlist service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WishlistClient interface {
	CreateWishlist(ctx context.Context, in *CreateWishlistRequest, opts ...grpc.CallOption) (*WishlistResponse, error)
	GetWishlist(ctx context.Context, in *GetWishlistRequest, opts ...grpc.CallOption) (*GetWishlistResponse, error)
	GetWishlistById(ctx context.Context, in *GetWishlistByIdRequest, opts ...grpc.CallOption) (*GetWishlistByIdResponse, error)
}

type wishlistClient struct {
	cc grpc.ClientConnInterface
}

func NewWishlistClient(cc grpc.ClientConnInterface) WishlistClient {
	return &wishlistClient{cc}
}

func (c *wishlistClient) CreateWishlist(ctx context.Context, in *CreateWishlistRequest, opts ...grpc.CallOption) (*WishlistResponse, error) {
	out := new(WishlistResponse)
	err := c.cc.Invoke(ctx, "/sale.Wishlist/CreateWishlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wishlistClient) GetWishlist(ctx context.Context, in *GetWishlistRequest, opts ...grpc.CallOption) (*GetWishlistResponse, error) {
	out := new(GetWishlistResponse)
	err := c.cc.Invoke(ctx, "/sale.Wishlist/GetWishlist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wishlistClient) GetWishlistById(ctx context.Context, in *GetWishlistByIdRequest, opts ...grpc.CallOption) (*GetWishlistByIdResponse, error) {
	out := new(GetWishlistByIdResponse)
	err := c.cc.Invoke(ctx, "/sale.Wishlist/GetWishlistById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WishlistServer is the server API for Wishlist service.
// All implementations must embed UnimplementedWishlistServer
// for forward compatibility
type WishlistServer interface {
	CreateWishlist(context.Context, *CreateWishlistRequest) (*WishlistResponse, error)
	GetWishlist(context.Context, *GetWishlistRequest) (*GetWishlistResponse, error)
	GetWishlistById(context.Context, *GetWishlistByIdRequest) (*GetWishlistByIdResponse, error)
	mustEmbedUnimplementedWishlistServer()
}

// UnimplementedWishlistServer must be embedded to have forward compatible implementations.
type UnimplementedWishlistServer struct {
}

func (UnimplementedWishlistServer) CreateWishlist(context.Context, *CreateWishlistRequest) (*WishlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWishlist not implemented")
}
func (UnimplementedWishlistServer) GetWishlist(context.Context, *GetWishlistRequest) (*GetWishlistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWishlist not implemented")
}
func (UnimplementedWishlistServer) GetWishlistById(context.Context, *GetWishlistByIdRequest) (*GetWishlistByIdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWishlistById not implemented")
}
func (UnimplementedWishlistServer) mustEmbedUnimplementedWishlistServer() {}

// UnsafeWishlistServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WishlistServer will
// result in compilation errors.
type UnsafeWishlistServer interface {
	mustEmbedUnimplementedWishlistServer()
}

func RegisterWishlistServer(s grpc.ServiceRegistrar, srv WishlistServer) {
	s.RegisterService(&Wishlist_ServiceDesc, srv)
}

func _Wishlist_CreateWishlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWishlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WishlistServer).CreateWishlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Wishlist/CreateWishlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WishlistServer).CreateWishlist(ctx, req.(*CreateWishlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wishlist_GetWishlist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWishlistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WishlistServer).GetWishlist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Wishlist/GetWishlist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WishlistServer).GetWishlist(ctx, req.(*GetWishlistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Wishlist_GetWishlistById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWishlistByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WishlistServer).GetWishlistById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Wishlist/GetWishlistById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WishlistServer).GetWishlistById(ctx, req.(*GetWishlistByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Wishlist_ServiceDesc is the grpc.ServiceDesc for Wishlist service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Wishlist_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sale.Wishlist",
	HandlerType: (*WishlistServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateWishlist",
			Handler:    _Wishlist_CreateWishlist_Handler,
		},
		{
			MethodName: "GetWishlist",
			Handler:    _Wishlist_GetWishlist_Handler,
		},
		{
			MethodName: "GetWishlistById",
			Handler:    _Wishlist_GetWishlistById_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sale.proto",
}

// FeedbackClient is the client API for Feedback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FeedbackClient interface {
	CreateFeedback(ctx context.Context, in *CreateFeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error)
	GetFeedback(ctx context.Context, in *GetFeedbackRequest, opts ...grpc.CallOption) (*GetFeedbackResponse, error)
	GetFeedbackOfUser(ctx context.Context, in *GetFeedbackOfUserRequest, opts ...grpc.CallOption) (*GetFeedbackOfUserResponse, error)
}

type feedbackClient struct {
	cc grpc.ClientConnInterface
}

func NewFeedbackClient(cc grpc.ClientConnInterface) FeedbackClient {
	return &feedbackClient{cc}
}

func (c *feedbackClient) CreateFeedback(ctx context.Context, in *CreateFeedbackRequest, opts ...grpc.CallOption) (*FeedbackResponse, error) {
	out := new(FeedbackResponse)
	err := c.cc.Invoke(ctx, "/sale.Feedback/CreateFeedback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackClient) GetFeedback(ctx context.Context, in *GetFeedbackRequest, opts ...grpc.CallOption) (*GetFeedbackResponse, error) {
	out := new(GetFeedbackResponse)
	err := c.cc.Invoke(ctx, "/sale.Feedback/GetFeedback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *feedbackClient) GetFeedbackOfUser(ctx context.Context, in *GetFeedbackOfUserRequest, opts ...grpc.CallOption) (*GetFeedbackOfUserResponse, error) {
	out := new(GetFeedbackOfUserResponse)
	err := c.cc.Invoke(ctx, "/sale.Feedback/GetFeedbackOfUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FeedbackServer is the server API for Feedback service.
// All implementations must embed UnimplementedFeedbackServer
// for forward compatibility
type FeedbackServer interface {
	CreateFeedback(context.Context, *CreateFeedbackRequest) (*FeedbackResponse, error)
	GetFeedback(context.Context, *GetFeedbackRequest) (*GetFeedbackResponse, error)
	GetFeedbackOfUser(context.Context, *GetFeedbackOfUserRequest) (*GetFeedbackOfUserResponse, error)
	mustEmbedUnimplementedFeedbackServer()
}

// UnimplementedFeedbackServer must be embedded to have forward compatible implementations.
type UnimplementedFeedbackServer struct {
}

func (UnimplementedFeedbackServer) CreateFeedback(context.Context, *CreateFeedbackRequest) (*FeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFeedback not implemented")
}
func (UnimplementedFeedbackServer) GetFeedback(context.Context, *GetFeedbackRequest) (*GetFeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeedback not implemented")
}
func (UnimplementedFeedbackServer) GetFeedbackOfUser(context.Context, *GetFeedbackOfUserRequest) (*GetFeedbackOfUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFeedbackOfUser not implemented")
}
func (UnimplementedFeedbackServer) mustEmbedUnimplementedFeedbackServer() {}

// UnsafeFeedbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeedbackServer will
// result in compilation errors.
type UnsafeFeedbackServer interface {
	mustEmbedUnimplementedFeedbackServer()
}

func RegisterFeedbackServer(s grpc.ServiceRegistrar, srv FeedbackServer) {
	s.RegisterService(&Feedback_ServiceDesc, srv)
}

func _Feedback_CreateFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServer).CreateFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Feedback/CreateFeedback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServer).CreateFeedback(ctx, req.(*CreateFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feedback_GetFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServer).GetFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Feedback/GetFeedback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServer).GetFeedback(ctx, req.(*GetFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Feedback_GetFeedbackOfUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFeedbackOfUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FeedbackServer).GetFeedbackOfUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Feedback/GetFeedbackOfUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FeedbackServer).GetFeedbackOfUser(ctx, req.(*GetFeedbackOfUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Feedback_ServiceDesc is the grpc.ServiceDesc for Feedback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Feedback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sale.Feedback",
	HandlerType: (*FeedbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFeedback",
			Handler:    _Feedback_CreateFeedback_Handler,
		},
		{
			MethodName: "GetFeedback",
			Handler:    _Feedback_GetFeedback_Handler,
		},
		{
			MethodName: "GetFeedbackOfUser",
			Handler:    _Feedback_GetFeedbackOfUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sale.proto",
}

// BoughtClient is the client API for Bought service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BoughtClient interface {
	CreateBought(ctx context.Context, in *CreateBoughtRequest, opts ...grpc.CallOption) (*BoughtResponse, error)
	GetBought(ctx context.Context, in *GetBoughtRequest, opts ...grpc.CallOption) (*GetBoughtResponse, error)
	GetBoughtOfUser(ctx context.Context, in *GetBoughtOfUserRequest, opts ...grpc.CallOption) (*GetBoughtOfUserResponse, error)
}

type boughtClient struct {
	cc grpc.ClientConnInterface
}

func NewBoughtClient(cc grpc.ClientConnInterface) BoughtClient {
	return &boughtClient{cc}
}

func (c *boughtClient) CreateBought(ctx context.Context, in *CreateBoughtRequest, opts ...grpc.CallOption) (*BoughtResponse, error) {
	out := new(BoughtResponse)
	err := c.cc.Invoke(ctx, "/sale.Bought/CreateBought", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boughtClient) GetBought(ctx context.Context, in *GetBoughtRequest, opts ...grpc.CallOption) (*GetBoughtResponse, error) {
	out := new(GetBoughtResponse)
	err := c.cc.Invoke(ctx, "/sale.Bought/GetBought", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *boughtClient) GetBoughtOfUser(ctx context.Context, in *GetBoughtOfUserRequest, opts ...grpc.CallOption) (*GetBoughtOfUserResponse, error) {
	out := new(GetBoughtOfUserResponse)
	err := c.cc.Invoke(ctx, "/sale.Bought/GetBoughtOfUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BoughtServer is the server API for Bought service.
// All implementations must embed UnimplementedBoughtServer
// for forward compatibility
type BoughtServer interface {
	CreateBought(context.Context, *CreateBoughtRequest) (*BoughtResponse, error)
	GetBought(context.Context, *GetBoughtRequest) (*GetBoughtResponse, error)
	GetBoughtOfUser(context.Context, *GetBoughtOfUserRequest) (*GetBoughtOfUserResponse, error)
	mustEmbedUnimplementedBoughtServer()
}

// UnimplementedBoughtServer must be embedded to have forward compatible implementations.
type UnimplementedBoughtServer struct {
}

func (UnimplementedBoughtServer) CreateBought(context.Context, *CreateBoughtRequest) (*BoughtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBought not implemented")
}
func (UnimplementedBoughtServer) GetBought(context.Context, *GetBoughtRequest) (*GetBoughtResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBought not implemented")
}
func (UnimplementedBoughtServer) GetBoughtOfUser(context.Context, *GetBoughtOfUserRequest) (*GetBoughtOfUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBoughtOfUser not implemented")
}
func (UnimplementedBoughtServer) mustEmbedUnimplementedBoughtServer() {}

// UnsafeBoughtServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BoughtServer will
// result in compilation errors.
type UnsafeBoughtServer interface {
	mustEmbedUnimplementedBoughtServer()
}

func RegisterBoughtServer(s grpc.ServiceRegistrar, srv BoughtServer) {
	s.RegisterService(&Bought_ServiceDesc, srv)
}

func _Bought_CreateBought_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBoughtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoughtServer).CreateBought(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Bought/CreateBought",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoughtServer).CreateBought(ctx, req.(*CreateBoughtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bought_GetBought_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoughtRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoughtServer).GetBought(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Bought/GetBought",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoughtServer).GetBought(ctx, req.(*GetBoughtRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bought_GetBoughtOfUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBoughtOfUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BoughtServer).GetBoughtOfUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sale.Bought/GetBoughtOfUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BoughtServer).GetBoughtOfUser(ctx, req.(*GetBoughtOfUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Bought_ServiceDesc is the grpc.ServiceDesc for Bought service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Bought_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sale.Bought",
	HandlerType: (*BoughtServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBought",
			Handler:    _Bought_CreateBought_Handler,
		},
		{
			MethodName: "GetBought",
			Handler:    _Bought_GetBought_Handler,
		},
		{
			MethodName: "GetBoughtOfUser",
			Handler:    _Bought_GetBoughtOfUser_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sale.proto",
}
